use std::{io::Read, path::PathBuf};

use clap::{ArgAction, Parser, ValueEnum};
use color_eyre::eyre::{Context as _, Result};
use typst_ansi_hl::Highlighter;

#[derive(clap::Parser)]
struct Args {
    /// The input path. If unset, stdin is used.
    input: Option<PathBuf>,

    /// Whether the input should be formatted to be Discord-compatible.
    #[clap(short, long)]
    discord: bool,

    // Logically this comes after `Args::strip_ansi`, but in clap it makes more sense before.
    // Also see https://jwodder.github.io/kbits/posts/clap-bool-negate/
    /// Strip all ANSI escape sequences from the input before processing. [default]
    #[clap(short = 's', long = "strip-ansi")]
    #[clap(hide_short_help = true, overrides_with = "strip_ansi")]
    #[doc(hidden)]
    _strip_ansi: bool,

    /// Don't remove escape sequences from the input.
    #[clap(
        action = ArgAction::SetFalse, // This turns the value *off*!
        short = 'S',                  //
        long = "no-strip-ansi",       // so this is not a bug!
    )]
    strip_ansi: bool,

    /// If the input is surrounded by an ANSI codeblock as generated by this tool, remove it.
    #[clap(short = 'c', long, overrides_with = "_no_unwrap_codeblock")]
    unwrap_codeblock: bool,

    /// Don't remove surrounding codeblock from the input. [default]
    #[clap(short = 'C', long = "no-unwrap-codeblock")]
    #[clap(hide_short_help = true)]
    #[doc(hidden)]
    _no_unwrap_codeblock: bool,

    /// Strip any top-level indentation in the input prior to highlighting it.
    #[clap(short = 'u', long, overrides_with = "_no_unindent")]
    unindent: bool,

    /// Keep indents as-is. [default]
    #[clap(short = 'U', long = "no-unindent")]
    #[clap(hide_short_help = true)]
    #[doc(hidden)]
    _no_unindent: bool,

    /// Softly enforce a byte size limit.
    ///
    /// This means that if the size limit is exceeded, less colors are used
    /// in order to get below that size limit.
    /// If it is not possible to get below that limit, the text is printed anyway.
    #[clap(short = 'l', long)]
    soft_limit: Option<usize>,

    /// The kind of input syntax.
    #[clap(short, long, default_value = "markup")]
    mode: SyntaxMode,
}

/// The kind of input syntax.
#[derive(Debug, Clone, Copy, ValueEnum)]
pub enum SyntaxMode {
    Code,
    Markup,
    Math,
}

impl From<SyntaxMode> for typst_ansi_hl::SyntaxMode {
    fn from(value: SyntaxMode) -> Self {
        match value {
            SyntaxMode::Code => typst_ansi_hl::SyntaxMode::Code,
            SyntaxMode::Markup => typst_ansi_hl::SyntaxMode::Markup,
            SyntaxMode::Math => typst_ansi_hl::SyntaxMode::Math,
        }
    }
}

fn main() -> Result<()> {
    color_eyre::install()?;

    let args = Args::parse();
    let mut input = String::new();
    if let Some(path) = &args.input {
        std::fs::File::open(path)
            .wrap_err_with(|| format!("failed to open file `{}`", path.display()))?
            .read_to_string(&mut input)
            .wrap_err_with(|| format!("failed to read file `{}`", path.display()))?;
    } else {
        std::io::stdin()
            .read_to_string(&mut input)
            .wrap_err("failed to read from stdin")?;
    }

    let mut stripped = if args.unwrap_codeblock {
        unwrap_codeblock(&input)
    } else {
        &input
    };

    if args.strip_ansi {
        input = strip_ansi_escapes::strip_str(stripped);
        stripped = &input;
    }

    if args.unindent {
        input = dedent(stripped);
        stripped = &input;
    }

    let out = termcolor::Ansi::new(std::io::stdout().lock());
    let mut highlighter = Highlighter::default();
    if args.discord {
        highlighter.for_discord();
    }
    highlighter.with_syntax_mode(args.mode.into());
    if let Some(soft_limit) = args.soft_limit {
        highlighter.with_soft_limit(soft_limit);
    }
    highlighter
        .highlight_to(stripped, out)
        .wrap_err("failed to highlight input")?;

    Ok(())
}

fn unwrap_codeblock(input: &str) -> &str {
    let Some(rest) = input.strip_prefix("```ansi\n") else {
        return input;
    };
    let rest = rest.trim_end();
    let Some(rest) = rest.strip_suffix("```") else {
        return input;
    };
    rest
}

fn dedent(input: &str) -> String {
    let shared_indent = input
        .lines()
        .filter(|l| !l.trim().is_empty())
        .map(|l| {
            let nonspace = l.find(|c: char| !c.is_whitespace()).unwrap();
            &l[..nonspace]
        })
        .min_by_key(|s| s.len() + s.matches('\t').count()) // Assume tabs are 2-wide
        .unwrap_or("");

    input
        .split_inclusive('\n')
        .map(|l| {
            if shared_indent.starts_with(l) {
                // Trim partial indents
                ""
            } else {
                l.strip_prefix(shared_indent).unwrap_or(l)
            }
        })
        .collect()
}
